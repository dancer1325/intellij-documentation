[//]: # (Source: https://www.jetbrains.com/help/idea/thread-dumps.html)
[//]: # (Downloaded: 2025-12-17 20:04:22)

## IntelliJ IDEA's thread dump format

When viewing IntelliJ IDEA's thread dump in text format, you might notice additional information in the thread descriptions and stack traces.

Here is an example of how it looks like:

"main" prio=5 tid=0x000001f3c9d13000 nid=NA runnable java.lang.Thread.State: RUNNABLE at java.net.SocketInputStream.socketRead0(Native Method) at java.net.SocketInputStream.socketRead(SocketInputStream.java:116) at java.net.SocketInputStream.read(SocketInputStream.java:171) at java.net.SocketInputStream.read(SocketInputStream.java:141) at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284) \- locked <0x00000007ab1d3fa8> (a java.io.InputStreamReader) at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326) at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178) 

Each thread in the dump is represented with the following information:

### Thread header Line

"Thread-Name" [state flags] prio=N tid=0xHEXVALUE nid=NA [thread state] 

Thread header line goes first in every thread description and consists of:

  * Thread name in quotes

  * Optional flags indicating if a thread is daemon or virtual

  * Thread priority (`prio`) – value managed by the JVM that indicates the thread's scheduling priority ranging from 1 (lowest) to 10 (highest). The default value is 5. These priorities may be mapped to OS-level thread priorities, however, the mapping is implementation-dependent, and priorities serve as hints to the scheduler rather than guarantees of execution order.

  * Thread ID in hexadecimal (`tid`)

  * Native ID (`nid`) – usually `NA` in IDE-generated dumps. This information is typically only available when thread dumps are generated by the JVM itself

  * Thread state. The following states are recognized:

Thread state| Description  
---|---  
`runnable`| thread is actively running or ready to run  
`sleeping`| thread is in a sleep state (`Thread.sleep()`)  
`waiting on condition`| thread is waiting for a condition  
`waiting for monitor entry`| thread is waiting to acquire a monitor lock  
`sleeping`| thread is in a sleep state (`Thread.sleep()`)  
`parking`| thread is parked (`LockSupport.park()`)  
`on object monitor`| thread is waiting on an object monitor  
`idle`| event dispatch thread is in an idle state  
  



### Thread state line

Thread state line goes right after the thread header line and contains the thread's state as indicated by the JVM. The following states are possible:

Thread state| Description  
---|---  
`NEW`| a thread that has not yet started execution  
`RUNNABLE`| a thread executing in the Java virtual machine  
`BLOCKED`| a thread blocked waiting for a monitor lock  
`WAITING`| a thread waiting indefinitely for another thread to perform a particular action  
`TIMED_WAITING`| a thread waiting for another thread to perform an action for up to a specified waiting time  
`TERMINATED`| a thread that has finished execution  
  
For more information on thread states, refer to [official Java documentation](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Thread.State.html).

### Stack trace

The stack trace shows the sequence of method calls for the thread, characterized by the following:

  * Each line in the stack trace begins with a tab character.

  * Method calls are listed from top (recent/called methods) to bottom (earlier/calling methods).

  * Each line follows the format: `at package.class.method(SourceFile:LineNumber)`. When IntelliJ IDEA recognizes the source file, you can use it to [navigate to the source code](#jump-to-source).




### Lock information

When available, IntelliJ IDEA's thread dumps provide information about locks held by the thread, including:

  * Monitors owned by this thread

  * Threads blocked by this thread

  * Monitors this thread is waiting for

  * Lock objects with their class and memory address




### Kotlin coroutines

You can view Kotlin coroutines in IntelliJ IDEA's thread dumps alongside Java threads. For example:

"coroutine:2" SUSPENDED at kotlinx.coroutines.DelayKt.awaitCancellation(Delay.kt:157) at NetworkServiceKt.fetchData(NetworkService.kt:15) at MainKt$main$1.invokeSuspend(Main.kt:11) at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33) 

The coroutines information is formatted as follows:

"CoroutineName:id" (state) [dispatcher] <coroutine descriptor> <stack trace>

  * Name and ID: The coroutine name followed by its unique ID, for example, `coroutine:1`

  * State: The coroutine's current state, for example, `SUSPENDED`

  * Dispatcher: Information about the dispatcher the coroutine is using, for example `Dispatchers.IO`

  * Stack trace: The coroutine's stack frames




Coroutines can be in one of the following states:

Coroutine state| Description  
---|---  
`RUNNING`| The coroutine is currently executing  
`SUSPENDED`| The coroutine is suspended at a suspension point  
`CREATED`| The coroutine has been created but not yet started  
`UNKNOWN`| The state cannot be determined
